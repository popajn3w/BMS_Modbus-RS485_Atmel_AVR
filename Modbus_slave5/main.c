/*******************************************************
This program was created by the CodeWizardAVR V3.37 
Automatic Program Generator
© Copyright 1998-2019 Pavel Haiduc, HP InfoTech s.r.l.
http://www.hpinfotech.com

Project : Modbus_slave5
Version : 1.05
Date    : 17.05.2023
Author  : popag93
Company : 
Comments: listens for Modbus queries on USART0,
          powers on or off the relays (interrupts/connects output)
          reads mains connection or analog inputs

Chip type               : ATmega8
Program type            : Application
AVR Core Clock frequency: 8.000000 MHz
Memory model            : Small
External RAM size       : 0
Data Stack size         : 256
*******************************************************/

#include <mega8.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <delay.h>
#include "defs.h"
void initController();


//*************************************************************************************************
//*********** BEGIN SERIAL STUFF (interrupt-driven, generated by Code Wizard) *********************
//*************************************************************************************************
#define DATA_REGISTER_EMPTY (1<<UDRE)
#define RX_COMPLETE (1<<RXC)
#define FRAMING_ERROR (1<<FE)
#define PARITY_ERROR (1<<UPE)
#define DATA_OVERRUN (1<<DOR)

// USART Receiver buffer
#define RX_BUFFER_SIZE 32
char rx_buffer[RX_BUFFER_SIZE];

#if RX_BUFFER_SIZE <= 256
unsigned char rx_wr_index=0,rx_rd_index=0;
#else
unsigned int rx_wr_index=0,rx_rd_index=0;
#endif

#if RX_BUFFER_SIZE < 256
unsigned char rx_counter=0;
#else
unsigned int rx_counter=0;
#endif

// This flag is set on USART Receiver buffer overflow
bit rx_buffer_overflow;

// USART Receiver interrupt service routine
interrupt [USART_RXC] void usart_rx_isr(void)
{
    char status,data;
    status=UCSRA;
    data=UDR;
    if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
    {
       rx_buffer[rx_wr_index++]=data;
    #if RX_BUFFER_SIZE == 256
       // special case for receiver buffer size=256
       if (++rx_counter == 0) rx_buffer_overflow=1;
    #else
       if (rx_wr_index == RX_BUFFER_SIZE) rx_wr_index=0;
       if (++rx_counter == RX_BUFFER_SIZE)
       {
          rx_counter=0;
          rx_buffer_overflow=1;
       }
    #endif
    }
}

#ifndef _DEBUG_TERMINAL_IO_
// Get a character from the USART Receiver buffer
#define _ALTERNATE_GETCHAR_
#pragma used+
char getchar(void)
{
    char data;
    while (rx_counter==0);
    data=rx_buffer[rx_rd_index++];
    #if RX_BUFFER_SIZE != 256
    if (rx_rd_index == RX_BUFFER_SIZE) rx_rd_index=0;
    #endif
    #asm("cli")
    --rx_counter;
    #asm("sei")
    return data;
}
#pragma used-
#endif

// USART Transmitter buffer
#define TX_BUFFER_SIZE 24
char tx_buffer[TX_BUFFER_SIZE];

#if TX_BUFFER_SIZE <= 256
unsigned char tx_wr_index=0,tx_rd_index=0;
#else
unsigned int tx_wr_index=0,tx_rd_index=0;
#endif

#if TX_BUFFER_SIZE < 256
unsigned char tx_counter=0;
#else
unsigned int tx_counter=0;
#endif

// USART Transmitter interrupt service routine
interrupt [USART_TXC] void usart_tx_isr(void)
{
    if (tx_counter)
    {
       --tx_counter;
       UDR=tx_buffer[tx_rd_index++];
    #if TX_BUFFER_SIZE != 256
       if (tx_rd_index == TX_BUFFER_SIZE) tx_rd_index=0;
    #endif
    }
    else
    {
        transceiver_datadir=0;
        LED1=0;
    }
}

#ifndef _DEBUG_TERMINAL_IO_
// Write a character to the USART Transmitter buffer
#define _ALTERNATE_PUTCHAR_
#pragma used+
void putchar(char c)
{
    while (tx_counter == TX_BUFFER_SIZE);
    #asm("cli")
    if (tx_counter || ((UCSRA & DATA_REGISTER_EMPTY)==0))
    {
       tx_buffer[tx_wr_index++]=c;
    #if TX_BUFFER_SIZE != 256
       if (tx_wr_index == TX_BUFFER_SIZE) tx_wr_index=0;
    #endif
       ++tx_counter;
    }
    else
       UDR=c;
    #asm("sei")
}
#pragma used-
#endif
//*************************************************************************************************
//******************************** END SERIAL STUFF ***********************************************
//*************************************************************************************************


//************************ timer0 *********************************************
// Timer 0 overflow interrupt service routine
// used to wake up from sleep to wdr
interrupt [TIM0_OVF] void timer0_ovf_isr(void)
{
    #asm("nop");
}
//*****************************************************************************

//************************* ADC ***********************************************
// Voltage Reference: AVCC pin
#define ADC_VREF_TYPE ((0<<REFS1) | (1<<REFS0) | (0<<ADLAR))

// ADC interrupt service routine
//used to exit sleep in read_adc() ??and clear ADIF??
interrupt [ADC_INT] void adc_isr(void)
{
    #asm("nop")
}

// Read the AD conversion result
unsigned int read_adc(unsigned char adc_input)
{
    ADMUX=adc_input | ADC_VREF_TYPE;
    // Delay needed for the stabilization of the ADC input voltage
    delay_us(10);
    // Start the AD conversion
    MCUCR |= 0b10010000;    //enable sleep, select ADC noise reduction mode
    #asm("sleep")           //ADCSRA|=(1<<ADSC); not needed, implicit in this mode
    MCUCR &= 0b00001111;    //disable sleep, select idle mode
    // Wait for the AD conversion to complete
    while ((ADCSRA & (1<<ADIF))==1);    //wait until ISR clears the bit
    return ADCW;
}
//*****************************************************************************

// convention:  msg - Modbus request;    rsp - Modbus response
char cr=0, *ct;
char *rsp=0, errmsg[24];
void senderr(flash const char *error)
{
    strcpyf(errmsg,error);
    transceiver_datadir=1;
    LED1=1;
    for(ct=errmsg; *ct; ct++)
        putchar(*ct);
    return;
}
void sendrsp()    //non deterministic behavior if I make it inline occurs
{                 //for :050400010001F5 and some :0506 requests
    transceiver_datadir=1;
    LED1=1;
    for(ct=rsp; *ct; ct++)
        putchar(*ct);
    return;
}


char msg[24], Nmsg;                         //Nmsg - msg[] after last element index (==length)
unsigned char LRC, slave_unit_addr;         //LRC - longitudinal checksum <=> checksum8 2's complement
char modbusFunc04();    char modbusFunc06();
char listen_validate_activate()             //returns: 0 if RL70|RL158 write, 1 if POWCON read
{                                           //         2 if A_IN4 read or A_IN5 read
    static int fctcode;                     //         4 if another unit_addr, 5 if improper msg

    
    do    //get first char only if ==':'
    {
        while(!rx_counter)    #asm("wdr");    //wait for RX0
        cr=getchar();
        //putchar1(cr);    //uncomment for debug
    }while(cr!=':');
    
    *msg=cr;
    Nmsg=1;
    do        //like Linux canonical serial com + Nmsg upper limit
    {
        if(Nmsg>17)
            return 5;
        if(rx_counter)
        {
            cr=getchar();
            //putchar1(cr);    //uncomment for debug
            msg[Nmsg++]=cr;
        }
        #asm("wdr");
    }while(cr!='\n');
    if(Nmsg!=17)
        return 5;
    msg[Nmsg++]='\0';
    
    
    
    /*while(rx_counter0)    getchar();    //empty rx0 buffer
    TCCR0B=0;    //stop_timer0();
    #asm("wdr");*/
    
    if(strncmpf(msg+1,_SLAVE_UNIT_ADDR,2))    //change to _SLAVE_UNIT_ADDR
        return 4;
    
    sscanf(msg+3,"%2x",&fctcode);
    switch(fctcode)
    {
    case 6:
        if(modbusFunc06())
            return 5;
        return 0;
        break;
    case 4:
        fctcode=modbusFunc04();
        if(fctcode==5)
            return 5;
        return fctcode;
        break;
    default:
        return 5;
    }
}

char modbusFunc06()
{
    static unsigned int RLval;
    static unsigned int LRC_RX;
    
    LRC = -slave_unit_addr -6;
    
    if(strncmpf(msg+5, "0000", 4))
        return 5;
    
    sscanf(msg+9, "%4x", &RLval);    //RLval-word-16bit
    LRC -= (RLval>>8) + RLval;
    
    sscanf(msg+13, "%2x", &LRC_RX);
    if(LRC != LRC_RX)
    {
        senderr("#LRCfail");    // ! must remove from final project
        return 5;
    }
    
    
    RLval = ~RLval;        //PORTB is connected to a RTL NOT gate
    RLval &= 0b111111;
    PORTB &= 0b11000000;
    PORTB |= RLval;
    
    sendrsp();        //ACK with same msg
    #asm("wdr");
    
    return 0;
}
char modbusFunc04()
{
    static unsigned char pinC;
    static unsigned int LRC_RX;
    static unsigned int addr1st;
    static unsigned int ADCval;
    
    ADCSRA |= 0b10000000;    //turn on ADC
    LRC = -slave_unit_addr -4;
    
    sscanf(msg+5,"%4x",&addr1st);
    LRC -= addr1st;
    if(strncmpf(msg+9, "0001", 4))
        return 5;
    LRC -= 1;
    
    sscanf(msg+13, "%2x", &LRC_RX);
    if(LRC != LRC_RX)
    {
        senderr("LRCfail");    //!must remove from final project
        return 5;
    }
    
    
    if(addr1st==1)
    {
        pinC = ~PINC;
        pinC &= 0b1111;
        LRC = -11 -pinC;    //= -5 -4 -2 -pinC
        sprintf(rsp, ":%02X040002000%X%02X\r\n", slave_unit_addr,pinC,LRC);
        sendrsp();
        #asm("wdr")
        return 1;    
    }
    else if(addr1st==4 || addr1st==5)
    {
        ADCval=read_adc(addr1st);
        LRC = -11 -(ADCval>>8) -ADCval;
        sprintf(rsp, ":%02X040002%04X%02X\r\n", slave_unit_addr,ADCval,LRC);
        sendrsp();
        #asm("wdr")
        return 2;
    }
    else
        return 5;
}

void main(void)
{
    unsigned char temp_ret;
        
    initController();
    
    // Globally enable interrupts
    #asm("sei")
    senderr("#reset\r\n");
    delay_ms(10);    //it was 50ms
    rsp=msg;
    strcpyf(rsp,_SLAVE_UNIT_ADDR);    //change to _SLAVE_UNIT_ADDR
    sscanf(rsp,"%2x",&slave_unit_addr);
    while (1)
    {
        #asm("wdr");
        ADCSRA &= 0b01111111;    //turn off ADC
        LED1=0;
        
        TCNT0=0x00;    //32.768ms timer0 sleep interval @ clk_CPU=8MHz
        TCCR0=0b101;
        while(!rx_counter)
        {
            LED1 = ~LED1;    //must remove from final project; just for debug
            MCUCR |= 0b10000000;    //set SE bit
            #asm("sleep")    //will wake up from timer, USART or watchdog (unexpected)
            MCUCR &= 0b01111111;    //clear SE bit
            #asm("wdr")
        }
        TCCR0=0x0;
        
        temp_ret=listen_validate_activate();
        /*sprintf(errmsg,"#returned %d\r\n",temp_ret);
        for(ct=errmsg; *ct; ct++)
            putchar(*ct);*/
        printf("#returned %d\r\n",temp_ret);    // ! must remove from final project
        
        
        if(rx_buffer_overflow)    //!must remove from final project
        {
            senderr("#RX_buffer_overflow\n");
            rx_buffer_overflow = 0;
        }
    }
    return;
}
