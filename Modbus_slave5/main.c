/*******************************************************
This program was created by the CodeWizardAVR V3.37 
Automatic Program Generator
© Copyright 1998-2019 Pavel Haiduc, HP InfoTech s.r.l.
http://www.hpinfotech.com

Project : Modbus_slave5
Version : 1.0
Date    : 15.03.2023
Author  : popag93
Company : 
Comments: listens for Modbus queries on USART0,
          powers on or off the relays if asked (interrupts/connects output)

Chip type               : ATmega164A
Program type            : Application
AVR Core Clock frequency: 20.000000 MHz
Memory model            : Small
External RAM size       : 0
Data Stack size         : 256
*******************************************************/

#include <mega164a.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <delay.h>
#include "defs.h"
void initController();

//static const char hextable[] = {[0...255]=-1, ['0']=0,1,2,3,4,5,6,7,8,9, ['A']=10,11,12,13,14,15, ['a']=10,11,12,13,14,15};
flash const char hextable[] = {
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1, 0,1,2,3,4,5,6,7,8,9,-1,-1,-1,-1,-1,-1,-1,10,11,12,13,14,15,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
};
void sscanf_2hhx(char *s, char *d)    //call this instead of sscanf(s, "%2hhx", d), which is not implemented
{
    *d=0;
    if(hextable[s[0]]!=-1)
        *d = hextable[s[0]]<<4;
    else
        return;
    if(hextable[s[1]]!=-1)
        *d += hextable[s[1]];
    
    return;
}

//*************************************************************************************************
//*********** BEGIN SERIAL STUFF (interrupt-driven, generated by Code Wizard) *********************
//*************************************************************************************************
#define getchar0 getchar
#define putchar0 putchar

#ifndef RXB8
#define RXB8 1
#endif

#ifndef TXB8
#define TXB8 0
#endif

#ifndef UPE
#define UPE 2
#endif

#ifndef DOR
#define DOR 3
#endif

#ifndef FE
#define FE 4
#endif

#ifndef UDRE
#define UDRE 5
#endif

#ifndef RXC
#define RXC 7
#endif

#define FRAMING_ERROR (1<<FE)
#define PARITY_ERROR (1<<UPE)
#define DATA_OVERRUN (1<<DOR)
#define DATA_REGISTER_EMPTY (1<<UDRE)
#define RX_COMPLETE (1<<RXC)

// USART0 Receiver buffer
#define RX_BUFFER_SIZE0 32
char rx_buffer0[RX_BUFFER_SIZE0];        //este un FIFO circular, wr_index pt intrari, rd_index pt iesiri

#if RX_BUFFER_SIZE0 <= 256
unsigned char rx_wr_index0,rx_rd_index0,rx_counter0;    //rx_counter0 counts unread data in the buffer
#else
unsigned int rx_wr_index0,rx_rd_index0,rx_counter0;
#endif

// This flag is set on USART0 Receiver buffer overflow
bit rx_buffer_overflow0;

// USART0 Receiver interrupt service routine
interrupt [USART0_RXC] void usart0_rx_isr(void)        //keyword "interrupt[<IV_index>]" ...<functie>
{
    char status,data;
    status=UCSR0A;
    data=UDR0;    //dupa se va sterge RXCF de hard
    if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)  //if(!(status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN)))
       {
       rx_buffer0[rx_wr_index0++]=data;
    #if RX_BUFFER_SIZE0 == 256
       // special case for receiver buffer size=256
       if (++rx_counter0 == 0) rx_buffer_overflow0=1;
    #else
       if (rx_wr_index0 == RX_BUFFER_SIZE0) rx_wr_index0=0;
       if (++rx_counter0 == RX_BUFFER_SIZE0)
          {
          rx_counter0=0;
          rx_buffer_overflow0=1;
          }
    #endif
       }
}

#ifndef _DEBUG_TERMINAL_IO_
// Get a character from the USART0 Receiver buffer
#define _ALTERNATE_GETCHAR_
#pragma used+
char getchar0(void)
{
    char data;
    while (rx_counter0==0);        //while no new data is present, wait
    data=rx_buffer0[rx_rd_index0++];
    #if RX_BUFFER_SIZE0 != 256
    if (rx_rd_index0 == RX_BUFFER_SIZE0) rx_rd_index0=0;
    #endif
    #asm("cli")
    --rx_counter0;    //oprit intreruperi deoarece operatie atomica ???
    #asm("sei")
    return data;
}
#pragma used-
#endif

// USART0 Transmitter buffer
#define TX_BUFFER_SIZE0 24
char tx_buffer0[TX_BUFFER_SIZE0];    //este un FIFO circular, wr_index pt intrari, rd pt iesiri catre TransmitBuffer

#if TX_BUFFER_SIZE0 <= 256
unsigned char tx_wr_index0,tx_rd_index0,tx_counter0;
#else
unsigned int tx_wr_index0,tx_rd_index0,tx_counter0;
#endif

// USART0 Transmitter interrupt service routine
interrupt [USART0_TXC] void usart0_tx_isr(void)
{
    if (tx_counter0)        //else, the buffer is empty, do nothing, starting the ISR clears TXCF
    {
       --tx_counter0;
       UDR0=tx_buffer0[tx_rd_index0++];
    #if TX_BUFFER_SIZE0 != 256
       if (tx_rd_index0 == TX_BUFFER_SIZE0) tx_rd_index0=0;
    #endif
    }
    else
    {
        transceiver_datadir=0;
        LED1=0;
    }
}

#ifndef _DEBUG_TERMINAL_IO_
// Write a character to the USART0 Transmitter buffer
#define _ALTERNATE_PUTCHAR_
#pragma used+
void putchar0(char c)
{
    while (tx_counter0 == TX_BUFFER_SIZE0);        //? si daca BUFFER_SIZE0==256 ??
    #asm("cli")
    if (tx_counter0 || ((UCSR0A & DATA_REGISTER_EMPTY)==0))      //a doua conditie este pt a nu fi in cazul in care doar ce am golit buffer-ul, insa nu s-a golit UDR0
       {
       tx_buffer0[tx_wr_index0++]=c;
    #if TX_BUFFER_SIZE0 != 256
       if (tx_wr_index0 == TX_BUFFER_SIZE0) tx_wr_index0=0;
    #endif
       ++tx_counter0;
       }
    else        //inseamna ca TXC=0 (sters de ISR) si UDRE=1
       UDR0=c;
    #asm("sei")
}
#pragma used-
#endif
//*************************************************************************************************
//******************** END SERIAL STUFF (USART0), BEGIN USART1  ***********************************
//*************************************************************************************************
/*
// USART1 Receiver buffer
#define RX_BUFFER_SIZE1 32
char rx_buffer1[RX_BUFFER_SIZE1];        //wr_index pt intrari, rd_index pt iesiri

#if RX_BUFFER_SIZE1 <= 256
unsigned char rx_wr_index1,rx_rd_index1,rx_counter1;    //rx_counter counts unread data in the buffer
#else
unsigned int rx_wr_index1,rx_rd_index1,rx_counter1;
#endif

// This flag is set on USART1 Receiver buffer overflow
bit rx_buffer_overflow1;

// USART1 Receiver interrupt service routine
interrupt [USART1_RXC] void usart1_rx_isr(void)        //keyword "interrupt[<IV_index>]" ...<functie>
{
    char status,data;
    status=UCSR1A;
    data=UDR1;    //dupa se va sterge RXCF de hard
    if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)  //if(!(status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN)))
    {
        rx_buffer1[rx_wr_index1++]=data;
    #if RX_BUFFER_SIZE1 == 256
        // special case for receiver buffer size=256
        if (++rx_counter1 == 0) rx_buffer_overflow1=1;
    #else
        if (rx_wr_index1 == RX_BUFFER_SIZE1) rx_wr_index1=0;
        if (++rx_counter1 == RX_BUFFER_SIZE1)
        {
            rx_counter1=0;
            rx_buffer_overflow1=1;
        }
    #endif
    }
}

#pragma used+
char getchar1(void)
{
    char data;
    while (rx_counter1==0);        //while no new data is present, wait
    data=rx_buffer1[rx_rd_index1++];
    #if RX_BUFFER_SIZE1 != 256
    if (rx_rd_index1 == RX_BUFFER_SIZE1) rx_rd_index1=0;
    #endif
    #asm("cli")
    --rx_counter1;    //oprit intreruperi deoarece operatie atomica ???
    #asm("sei")
    return data;
}
#pragma used-

// USART1 Transmitter buffer
#define TX_BUFFER_SIZE1 24
char tx_buffer1[TX_BUFFER_SIZE1];    //wr_index pt intrari, rd pt iesiri catre TransmitBuffer

#if TX_BUFFER_SIZE1 <= 256
unsigned char tx_wr_index1,tx_rd_index1,tx_counter1;
#else
unsigned int tx_wr_index1,tx_rd_index1,tx_counter1;
#endif

// USART1 Transmitter interrupt service routine
interrupt [USART1_TXC] void usart1_tx_isr(void)
{
    if (tx_counter1)        //else, the buffer is empty, do nothing, starting the ISR clears TXCF
    {
       --tx_counter1;
       UDR1=tx_buffer1[tx_rd_index1++];
    #if TX_BUFFER_SIZE1 != 256
       if (tx_rd_index1 == TX_BUFFER_SIZE1) tx_rd_index1=0;
    #endif
    }
    else
    {
        transceiver_datadir=0;
        LED1=0;
    }
}

#pragma used+
void putchar1(char c)
{
    while (tx_counter1 == TX_BUFFER_SIZE1);        //? si daca BUFFER_SIZE1==256 ??
    #asm("cli")
    if (tx_counter1 || ((UCSR1A & DATA_REGISTER_EMPTY)==0))      //a doua conditie este pt a nu fi in cazul in care doar ce am golit buffer-ul, insa nu s-a golit UDR0
    {
       tx_buffer1[tx_wr_index1++]=c;
    #if TX_BUFFER_SIZE1 != 256
       if (tx_wr_index1 == TX_BUFFER_SIZE1) tx_wr_index1=0;
    #endif
       ++tx_counter1;
    }
    else        //inseamna ca TXC=0 (sters de ISR) si UDRE=1
       UDR1=c;
    #asm("sei")
}
#pragma used-
*/
//*************************************************************************************************
//************************* END SERIAL STUFF (USART1) *********************************************
//*************************************************************************************************

// Pin change 24-31 interrupt service routine
interrupt [PC_INT3] void pin_change_isr3(void)
{
    LED1=PROBEtoLED;
}

// convention:  msg - Modbus request;    rsp - Modbus response
char cr=0, *ct;
char *rsp=0, errmsg[24];
void senderr(flash const char *error)
{
    strcpyf(errmsg,error);
    transceiver_datadir=1;
    LED1=1;
    for(ct=errmsg; *ct; ct++)
        putchar0(*ct);
    return;
}
void sendrsp()    //non deterministic behavior if I make it inline occurs
{                 //for :050400010001F5 and some :0506 requests
    transceiver_datadir=1;
    LED1=1;
    for(ct=rsp; *ct; ct++)
    {
        putchar0(*ct);
        //putchar1(*ct);    //uncomment for debug
    }
    return;
}


char msg[24], Nmsg;                      //Nmsg - msg[] after last element index (==length)
unsigned char LRC, i=0, slave_unit_addr;    //LRC - longitudinal checksum <=> checksum8 2's complement
char modbusFunc04();    char modbusFunc06();
char listen_validate_activate()             //returns: 0 if RL70|RL158 write, 2 if PINC read
{                                           //         4 if another unit_addr, 5 if improper msg         
    static int fctcode;

    
    do    //get first char only if ==':'
    {
        while(!rx_counter0)    #asm("wdr");    //wait for RX0
        cr=getchar0();
        //putchar1(cr);    //uncomment for debug
    }while(cr!=':');
    
    *msg=cr;
    Nmsg=1;
    do        //like Linux canonical serial com + Nmsg upper limit
    {
        if(Nmsg>17)
            return 5;
        if(rx_counter0)
        {
            cr=getchar0();
            //putchar1(cr);    //uncomment for debug
            msg[Nmsg++]=cr;
        }
        #asm("wdr");
    }while(cr!='\n');
    if(Nmsg!=17)
        return 5;
    msg[Nmsg++]='\0';
    
    
    
    /*while(rx_counter0)    getchar0();    //empty rx0 buffer
    TCCR0B=0;    //stop_timer0();
    #asm("wdr");*/
    
    //LED1=1;  delay_ms(10);  LED1=0;
    
    if(strncmpf(msg+1,"05",2))    //change to _SLAVE_UNIT_ADDR
        return 4;
    
    sscanf(msg+3,"%2x",&fctcode);
    switch(fctcode)
    {
    case 6:
        if(modbusFunc06())
            return 5;
        return 0;
        break;
    case 4:
        if(modbusFunc04())
            return 5;
        return 2;
        break;
    default:
        return 5;
    }
}

char modbusFunc06()
{
    static unsigned int RLval;
    static unsigned int LRC_RX;
    
    LRC = -slave_unit_addr -6;
    
    if(strncmpf(msg+5, "0000", 4))
        return 5;
    
    sscanf(msg+9, "%4x", &RLval);    //RLval-word-16bit
    LRC -= (RLval>>8) + RLval;
    
    sscanf(msg+13, "%2x", &LRC_RX);
    if(LRC != LRC_RX)
    {
        senderr("#LRCfail");    // ! must remove from final project
        return 5;
    }
    
    
    PORTA = ~RLval>>8;
    PORTB = ~RLval;    //PORTB = RLval&0xFF;
    
    sendrsp();        //ACK with same msg
    #asm("wdr");
    
    return 0;
}
char modbusFunc04()
{
    static unsigned char pinC;
    static unsigned int LRC_RX;
    
    LRC = -slave_unit_addr -4;
    
    if(strncmpf(msg+5, "0001", 4))
        return 5;
    LRC -= 1;
    if(strncmpf(msg+9, "0001", 4))
        return 5;
    LRC -= 1;
    
    sscanf(msg+13, "%2x", &LRC_RX);
    if(LRC != LRC_RX)
    {
        senderr("LRCfail");
        return 5;
    }
    
    
    pinC = ~PINC;
    LRC = -11 -pinC;
    sprintf(rsp, ":05040002%02X00%02X\r\n", pinC,LRC);
    sendrsp();
    #asm("wdr");
    
    return 0;
}

void main(void)
{
    unsigned char temp_ret;
    //unsigned int time1;
        
    initController();
    
    // Globally enable interrupts
    #asm("sei")
    senderr("#reset\r\n");
    delay_ms(50);
    rsp=msg;
    strcpyf(rsp,"05");    //change to _SLAVE_UNIT_ADDR
    sscanf(rsp,"%2x",&slave_unit_addr);
    while (1)
    {
        #asm("wdr");
        
        LED1=0;
        
        temp_ret=listen_validate_activate();
        /*sprintf(errmsg,"#returned %d\r\n",temp_ret);
        for(ct=errmsg; *ct; ct++)
            putchar0(*ct);*/
        printf("#returned %d\r\n",temp_ret);    // ! must remove from final project
        
        //LED1=1;  delay_ms(50);  LED1=0;    // ! must remove from final project
        
        if(rx_buffer_overflow0)
        {
            senderr("#RX0_buffer_overflow\n");
            rx_buffer_overflow0 = 0;
        }
    }
}