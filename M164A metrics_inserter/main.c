/*******************************************************
This program was created by the CodeWizardAVR V3.37
Automatic Program Generator
© Copyright 1998-2019 Pavel Haiduc, HP InfoTech s.r.l.
http://www.hpinfotech.com

Project : metrics_inserter_uC
Version : 1.06
Date    : 23.05.2023
Author  : popag93
Company :
Comments: queries the meter, computes mean on 5s from 5 values
          and sends MySQL queries on USART0 to insert metrics;
          queries the custom Modbus slave to actuate the relays
          according to the switches and get analog inputs

Chip type               : ATmega164A
Program type            : Application
AVR Core Clock frequency: 20.000000 MHz
Memory model            : Small
External RAM size       : 0
Data Stack size         : 256
*******************************************************/

#include <mega164a.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <delay.h>
#include "defs.h"
void initController();

//static const char hextable[] = {[0...255]=-1, ['0']=0,1,2,3,4,5,6,7,8,9, ['A']=10,11,12,13,14,15, ['a']=10,11,12,13,14,15};
flash const char hextable[] = {
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1, 0,1,2,3,4,5,6,7,8,9,-1,-1,-1,-1,-1,-1,-1,10,11,12,13,14,15,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
};
void sscanf_2hhx(char *s, char *d)    //call this instead of sscanf(s, "%2hhx", d), which is not implemented
{
    *d=0;
    if(hextable[s[0]]!=-1)
        *d = hextable[s[0]]<<4;
    else
        return;
    if(hextable[s[1]]!=-1)
        *d += hextable[s[1]];

    return;
}

//*************************************************************************************************
//*********** BEGIN SERIAL STUFF (interrupt-driven, generated by Code Wizard) *********************
//*************************************************************************************************
#define getchar0 getchar
#define putchar0 putchar

#ifndef RXB8
#define RXB8 1
#endif

#ifndef TXB8
#define TXB8 0
#endif

#ifndef UPE
#define UPE 2
#endif

#ifndef DOR
#define DOR 3
#endif

#ifndef FE
#define FE 4
#endif

#ifndef UDRE
#define UDRE 5
#endif

#ifndef RXC
#define RXC 7
#endif

#define FRAMING_ERROR (1<<FE)
#define PARITY_ERROR (1<<UPE)
#define DATA_OVERRUN (1<<DOR)
#define DATA_REGISTER_EMPTY (1<<UDRE)
#define RX_COMPLETE (1<<RXC)

// USART0 Receiver buffer
#define RX_BUFFER_SIZE0 8
char rx_buffer0[RX_BUFFER_SIZE0];        //este un FIFO circular, wr_index pt intrari, rd_index pt iesiri

#if RX_BUFFER_SIZE0 <= 256
unsigned char rx_wr_index0,rx_rd_index0,rx_counter0;    //rx_counter0 counts unread data in the buffer
#else
unsigned int rx_wr_index0,rx_rd_index0,rx_counter0;
#endif

// This flag is set on USART0 Receiver buffer overflow
bit rx_buffer_overflow0;

// USART0 Receiver interrupt service routine
interrupt [USART0_RXC] void usart0_rx_isr(void)        //keyword "interrupt[<IV_index>]" ...<functie>
{
    char status,data;
    status=UCSR0A;
    data=UDR0;    //dupa se va sterge RXCF de hard
    if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)  //if(!(status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN)))
       {
       rx_buffer0[rx_wr_index0++]=data;
    #if RX_BUFFER_SIZE0 == 256
       // special case for receiver buffer size=256
       if (++rx_counter0 == 0) rx_buffer_overflow0=1;
    #else
       if (rx_wr_index0 == RX_BUFFER_SIZE0) rx_wr_index0=0;
       if (++rx_counter0 == RX_BUFFER_SIZE0)
          {
          rx_counter0=0;
          rx_buffer_overflow0=1;
          }
    #endif
       }
}

#ifndef _DEBUG_TERMINAL_IO_
// Get a character from the USART0 Receiver buffer
#define _ALTERNATE_GETCHAR_
#pragma used+
char getchar0(void)
{
    char data;
    while (rx_counter0==0);        //while no new data is present, wait
    data=rx_buffer0[rx_rd_index0++];
    #if RX_BUFFER_SIZE0 != 256
    if (rx_rd_index0 == RX_BUFFER_SIZE0) rx_rd_index0=0;
    #endif
    #asm("cli")
    --rx_counter0;    //oprit intreruperi deoarece operatie atomica ???
    #asm("sei")
    return data;
}
#pragma used-
#endif

// USART0 Transmitter buffer
#define TX_BUFFER_SIZE0 24
char tx_buffer0[TX_BUFFER_SIZE0];    //este un FIFO circular, wr_index pt intrari, rd pt iesiri catre TransmitBuffer

#if TX_BUFFER_SIZE0 <= 256
unsigned char tx_wr_index0,tx_rd_index0,tx_counter0;
#else
unsigned int tx_wr_index0,tx_rd_index0,tx_counter0;
#endif

// USART0 Transmitter interrupt service routine
interrupt [USART0_TXC] void usart0_tx_isr(void)
{
    if (tx_counter0)        //else, the buffer is empty, do nothing, starting the ISR clears TXCF
    {
       --tx_counter0;
       UDR0=tx_buffer0[tx_rd_index0++];
    #if TX_BUFFER_SIZE0 != 256
       if (tx_rd_index0 == TX_BUFFER_SIZE0) tx_rd_index0=0;
    #endif
    }
}

#ifndef _DEBUG_TERMINAL_IO_
// Write a character to the USART0 Transmitter buffer
#define _ALTERNATE_PUTCHAR_
#pragma used+
void putchar0(char c)
{
    while (tx_counter0 == TX_BUFFER_SIZE0);        //? si daca BUFFER_SIZE0==256 ??
    #asm("cli")
    if (tx_counter0 || ((UCSR0A & DATA_REGISTER_EMPTY)==0))      //a doua conditie este pt a nu fi in cazul in care doar ce am golit buffer-ul, insa nu s-a golit UDR0
       {
       tx_buffer0[tx_wr_index0++]=c;
    #if TX_BUFFER_SIZE0 != 256
       if (tx_wr_index0 == TX_BUFFER_SIZE0) tx_wr_index0=0;
    #endif
       ++tx_counter0;
       }
    else        //inseamna ca TXC=0 (sters de ISR) si UDRE=1
       UDR0=c;
    #asm("sei")
}
#pragma used-
#endif
//*************************************************************************************************
//******************** END SERIAL STUFF (USART0), BEGIN USART1  ***********************************
//*************************************************************************************************

// USART1 Receiver buffer
#define RX_BUFFER_SIZE1 32
char rx_buffer1[RX_BUFFER_SIZE1];        //wr_index pt intrari, rd_index pt iesiri

#if RX_BUFFER_SIZE1 <= 256
unsigned char rx_wr_index1,rx_rd_index1,rx_counter1;    //rx_counter counts unread data in the buffer
#else
unsigned int rx_wr_index1,rx_rd_index1,rx_counter1;
#endif

// This flag is set on USART1 Receiver buffer overflow
bit rx_buffer_overflow1;

// USART1 Receiver interrupt service routine
interrupt [USART1_RXC] void usart1_rx_isr(void)        //keyword "interrupt[<IV_index>]" ...<functie>
{
    char status,data;
    status=UCSR1A;
    data=UDR1;    //dupa se va sterge RXCF de hard
    if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)  //if(!(status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN)))
    {
        rx_buffer1[rx_wr_index1++]=data;
    #if RX_BUFFER_SIZE1 == 256
        // special case for receiver buffer size=256
        if (++rx_counter1 == 0) rx_buffer_overflow1=1;
    #else
        if (rx_wr_index1 == RX_BUFFER_SIZE1) rx_wr_index1=0;
        if (++rx_counter1 == RX_BUFFER_SIZE1)
        {
            rx_counter1=0;
            rx_buffer_overflow1=1;
        }
    #endif
    }
}

#pragma used+
char getchar1(void)
{
    char data;
    while (rx_counter1==0);        //while no new data is present, wait
    data=rx_buffer1[rx_rd_index1++];
    #if RX_BUFFER_SIZE1 != 256
    if (rx_rd_index1 == RX_BUFFER_SIZE1) rx_rd_index1=0;
    #endif
    #asm("cli")
    --rx_counter1;    //oprit intreruperi deoarece operatie atomica ???
    #asm("sei")
    return data;
}
#pragma used-

// USART1 Transmitter buffer
#define TX_BUFFER_SIZE1 24
char tx_buffer1[TX_BUFFER_SIZE1];    //wr_index pt intrari, rd pt iesiri catre TransmitBuffer

#if TX_BUFFER_SIZE1 <= 256
unsigned char tx_wr_index1,tx_rd_index1,tx_counter1;
#else
unsigned int tx_wr_index1,tx_rd_index1,tx_counter1;
#endif

// USART1 Transmitter interrupt service routine
interrupt [USART1_TXC] void usart1_tx_isr(void)
{
    if (tx_counter1)        //else, the buffer is empty, do nothing, starting the ISR clears TXCF
    {
       --tx_counter1;
       UDR1=tx_buffer1[tx_rd_index1++];
    #if TX_BUFFER_SIZE1 != 256
       if (tx_rd_index1 == TX_BUFFER_SIZE1) tx_rd_index1=0;
    #endif
    }
    else
    {
        transceiver_datadir=0;
        LED1=0;
    }
}

#pragma used+
void putchar1(char c)
{
    while (tx_counter1 == TX_BUFFER_SIZE1);        //? si daca BUFFER_SIZE1==256 ??
    #asm("cli")
    if (tx_counter1 || ((UCSR1A & DATA_REGISTER_EMPTY)==0))      //a doua conditie este pt a nu fi in cazul in care doar ce am golit buffer-ul, insa nu s-a golit UDR0
    {
       tx_buffer1[tx_wr_index1++]=c;
    #if TX_BUFFER_SIZE1 != 256
       if (tx_wr_index1 == TX_BUFFER_SIZE1) tx_wr_index1=0;
    #endif
       ++tx_counter1;
    }
    else        //inseamna ca TXC=0 (sters de ISR) si UDRE=1
       UDR1=c;
    #asm("sei")
}
#pragma used-
//*************************************************************************************************
//************************* END SERIAL STUFF (USART1) *********************************************
//*************************************************************************************************

volatile unsigned char pinA;    //stable, decided relay states
struct DMED121{
    // long int in CVAVR C Compiler is int32_t, int is int16_t
    unsigned long int I;
    unsigned long int P;
    unsigned long int Q;
    unsigned long int V;
};
struct DMED301{
    unsigned long int I1;    //current
    unsigned long int I2;
    unsigned long int I3;
    unsigned long int P1;    //active power
    unsigned long int P2;
    unsigned long int P3;
    unsigned long int Q1;    //reactive power
    unsigned long int Q2;
    unsigned long int Q3;
    unsigned long int S1;    //apparent power
    unsigned long int S2;
    unsigned long int S3;
};
struct Slave05{
    unsigned int powcon;
    unsigned int ain4;
    unsigned int ain5;
};

#define SW_OCR0 124
volatile unsigned char time0;    //time0 sw timer - 125 steps; hw timer 125 steps, 64 prescaler -> 64/20000*125*125=50ms
inline void start_timer0()
{
    time0=0;
    TCNT0=0;
    TCCR0B=0b0011;
}
inline void stop_timer0()
{
    TCCR0B=0;
}
// Timer 0 output compare A interrupt service routine
interrupt [TIM0_COMPA] void timer0_compa_isr(void)
{
    if(time0<SW_OCR0)
        time0++;
    else
        TCCR0B=0;
}

inline void start_timer1()
{
    TCNT1H=0;
    TCNT1L=0;
    TCCR1B=0b1101;
}
inline void stop_timer1()
{
    TCCR1B=0;
}
// Timer1 output compare A interrupt service routine
interrupt [TIM1_COMPA] void timer1_compa_isr(void)
{
    TCCR1B=0x00;    //stop timer
}

volatile unsigned char time2=0;    //time2 sw timer - 10 steps; hw timer 250 steps, 256 prescaler -> 256/20000*250*10=32ms
interrupt [TIM2_COMPA] void timer2_compa_isr(void)
{
    if(time2++ >=9)
    {
        TCCR2B=0;
        pinA=PINA;
    }
}

interrupt [PC_INT0] void pin_change_isr0(void)
{
    TCCR2B=0b110;
    time2=0;
}


// convention:  msg - Modbus request;    rsp - Modbus response
unsigned char cr=0, *ct;
char msg[40], errmsg[24];
//struct DMED121 c1;                //measurement set for energymeter 1
void senderr(flash const char *error)
{
    strcpyf(errmsg,error);
    for(ct=errmsg; *ct; ct++)
        putchar0(*ct);
    return;
}
void sendmsg()
{
    transceiver_datadir=1;
    LED1=1;
    for(ct=msg; *ct; ct++)
    {
        putchar1(*ct);
        //putchar0(*ct);    //uncomment for debug
    }
    return;
}
void sendqry()    //make it inline if there's enough program memory
{
    for(ct=msg; *ct; ct++)
        putchar0(*ct);
    return;
}

char rsp[64], Nrsp;        //Nrsp - rsp[] after last element index (==length)
unsigned char LRC, i=0;    //LRC - longitudinal checksum <=> checksum8 2's complement
unsigned long int val;
char ask_listen_validate03(const unsigned char addr)
{
    char *rsp0;    //local variable for rsp

    delay_ms(3);
    start_timer0();
    sendmsg();


    while(!rx_counter1)    //wait first char, timeout time0
        if(time0 == SW_OCR0)
        {
            senderr("#fail1");
            return 1;
        }
    cr=getchar1();
    //putchar0(cr);    //uncomment for debug
    *rsp=cr;
    Nrsp=1;
    while(cr!='\n')        //like Linux canonical serial com + timeout
    {
        if(time0 == SW_OCR0)
        {
            senderr("#fail2");
            return 1;
        }
        if(rx_counter1)
        {
            cr=getchar1();
            //putchar0(cr);    //uncomment for debug
            rsp[Nrsp++]=cr;
        }
    }
    rsp[Nrsp++]='\0';

    while(rx_counter1)    getchar1();    //empty rx1 buffer
    TCCR0B=0;    //stop_timer0();
    #asm("wdr");


    for(i=0;  Nrsp-i>19 && rsp[i]!=':';  i++);    //ignore leading noise
    if(Nrsp-i != 20)                              //without leading noise, 20B response expected (including '\0', begins with ':')
    {
        senderr("#fail3");
        return 1;
    }
    rsp0=rsp+i;

    switch(addr)
    {
    case 1:
        if(strncmpf(rsp0,":01",3))
        {
            senderr("#fail4");
            return 1;
        }
        break;
    case 2:
        if(strncmpf(rsp0,":02",3))
        {
            senderr("#fail4");
            return 1;
        }
        break;
    case 3:
        if(strncmpf(rsp0,":03",3))
        {
            senderr("#fail4");
            return 1;
        }
        break;
    case 4:
        if(strncmpf(rsp0,":04",3))
        {
            senderr("#fail4");
            return 1;
        }
        break;
    default:
        return 1;
    }
    LRC = -addr;

    if(strncmpf(rsp0+3, "0304", 4))
        return 1;
    LRC -= 7;

    sscanf(rsp0+7,"%8lx",&val);
    LRC -= (val>>24) + (val>>16) + (val>>8) + val;

    sscanf_2hhx(rsp0+15, &cr);
    if(LRC != cr)
    {
        senderr("#LRCfail");
        return 1;
    }

    #asm("wdr");
    return 0;    //'\r' before last char test ignored
}

char ask_listen_validate06()
{
    char *rsp0;    //local variable for rsp

    delay_ms(3);
    start_timer0();
    sendmsg();


    while(!rx_counter1)    //wait first char, timeout time0
        if(time0 == SW_OCR0)
        {
            senderr("#fail1");
            return 1;
        }
    cr=getchar1();
    //putchar0(cr);    //uncomment for debug
    *rsp=cr;
    Nrsp=1;
    while(cr!='\n')        //like Linux canonical serial com + timeout
    {
        if(time0 == SW_OCR0)
        {
            senderr("#fail2");
            return 1;
        }
        if(rx_counter1)
        {
            cr=getchar1();
            //putchar0(cr);    //uncomment for debug
            rsp[Nrsp++]=cr;
        }
    }
    rsp[Nrsp++]='\0';

    while(rx_counter1)    getchar1();    //empty rx1 buffer
    TCCR0B=0;    //stop_timer0();
    #asm("wdr");


    for(i=0;  Nrsp-i>17 && rsp[i]!=':';  i++);    //ignore leading noise
    if(Nrsp-i != 18)                              //without leading noise, 18B response expected (including '\0', begins with ':')
    {
        senderr("#fail3");
        return 1;
    }
    rsp0=rsp+i;

    if(strncmp(msg,rsp0,17))
    {
        senderr("#fail5");
        return 1;
    }
    return 0;
}

unsigned int ask_listen_validate04(unsigned int* pval)
{
    unsigned int LRC_RX, RXval;
    char *rsp0;    //local variable for rsp

    delay_ms(3);
    start_timer0();
    sendmsg();


    while(!rx_counter1)    //wait first char, timeout time0
        if(time0 == SW_OCR0)
        {
            senderr("#fail1");
            return 1;
        }
    cr=getchar1();
    //putchar0(cr);    //uncomment for debug
    *rsp=cr;
    Nrsp=1;
    while(cr!='\n')        //like Linux canonical serial com + timeout
    {
        if(time0 == SW_OCR0)
        {
            senderr("#fail2");
            return 1;
        }
        if(rx_counter1)
        {
            cr=getchar1();
            //putchar0(cr);    //uncomment for debug
            rsp[Nrsp++]=cr;
        }
    }
    rsp[Nrsp++]='\0';

    while(rx_counter1)    getchar1();    //empty rx1 buffer
    TCCR0B=0;    //stop_timer0();
    #asm("wdr");

    for(i=0;  Nrsp-i>17 && rsp[i]!=':';  i++);    //ignore leading noise
    if(Nrsp-i != 18)                              //without leading noise, 18B response expected (including '\0', begins with ':')
    {
        senderr("#fail3");
        return 1;
    }
    rsp0=rsp+i;


    if(strncmp(rsp0,msg,5))
    {
        senderr("#fail4");
        return 1;
    }
    if(strncmpf(rsp0+5,"0002",4))
    {
        senderr("#fail4");
        return 1;
    }

    sscanf(rsp0+1,"%4x",&RXval);    //unit addr, Modbus fct
    LRC = -(RXval>>8) -RXval -2;
    sscanf(rsp0+9,"%4x",&RXval);    //value of input register
    LRC -= (RXval>>8) +RXval;
    sscanf(rsp0+13,"%2x",&LRC_RX);
    if(LRC != LRC_RX)
    {
        senderr("#LRCfail");
        return 1;
    }
    //else everything alright, store RXval
    *pval=RXval;
    return 0;
}

void main(void)
{
    unsigned char iretry, ic1=0, ic2=0, ic3=0, ic4=0, is5;
    unsigned char pinAbak=255, pinAreq, LRC_TX;    //known set relay states, temp value to request
    unsigned int time1, retval;
    struct DMED121 c1;                //measurement set for energymeter 1
    struct DMED301 c2, c3, c4;        //measurement sets for energymeters 2-4
    struct Slave05 s5;

    initController();
    pinA=PINA;
    memset(&c1, 0, sizeof(struct DMED121));
    memset(&c2, 0, sizeof(struct DMED301));
    memset(&c3, 0, sizeof(struct DMED301));
    memset(&c4, 0, sizeof(struct DMED301));
    memset(&s5, 0, sizeof(struct Slave05));

    // Globally enable interrupts
    #asm("sei")
    senderr("#reset\r\n");
    while (1)
    {

param_set1:
        start_timer1();
        #asm("wdr");
        strcpyf(msg, ":010300070002F3\r\n");    //:010300070002F3\r\n
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(1))
            {
                c1.I += val/5;
                break;
            }
            else
            {
failed_q1:      #asm("wdr");
                senderr("#retry_q1\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q1->c1_fail\n");
            ic1=0;
            memset(&c1,0,sizeof(struct DMED121));    //clear param_set
            goto param_set2;
        }

        strcpyf(msg,":010300130002E7\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(1))
            {
                c1.P += val/5;
                break;
            }
            else
            {
failed_q2:      #asm("wdr");
                senderr("#retry_q2\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q2->c1_fail\n");
            ic1=0;
            memset(&c1,0,sizeof(struct DMED121));    //clear param_set
            goto param_set2;
        }

        strcpyf(msg,":010300190002E1\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(1))
            {
                c1.Q += val/5;
                break;
            }
            else
            {
failed_q3:      #asm("wdr");
                senderr("#retry_q3\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q3->c1_fail\n");
            ic1=0;
            memset(&c1,0,sizeof(struct DMED121));    //clear param_set
            goto param_set2;
        }

        strcpyf(msg,":010300010002F9\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(1))
            {
                c1.V += val/5;
                break;
            }
            else
            {
failed_q4:      #asm("wdr");
                senderr("#retry_q4\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q4->c1_fail\n");
            ic1=0;
            memset(&c1,0,sizeof(struct DMED121));    //clear param_set
            goto param_set2;
        }


        if(++ic1==5)    // 5 values acquired, insert obtained mean
        {
            strcpyf(msg,"CALL insert_em1(");
            sendqry();
            #asm("wdr");
            sprintf(msg,"%ld,%ld,%ld,%ld);\n", c1.I, c1.P, c1.Q, c1.V);
            sendqry();
            ic1=0;
            memset(&c1,0,sizeof(struct DMED121));    //clear param_set
        }



param_set2:
        strcpyf(msg,":020300070002F2\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(2))
            {
                c2.I1 += val/5;
                break;
            }
            else
            {
failed_q5:      #asm("wdr");
                senderr("#retry_q5\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q5->c2_fail\n");
            ic2=0;
            memset(&c2,0,sizeof(struct DMED301));    //clear param_set
            goto param_set3;
        }

        strcpyf(msg,":020300090002F0\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(2))
            {
                c2.I2 += val/5;
                break;
            }
            else
            {
failed_q6:      #asm("wdr");
                senderr("#retry_q6\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q6->c2_fail\n");
            ic2=0;
            memset(&c2,0,sizeof(struct DMED301));    //clear param_set
            goto param_set3;
        }

        strcpyf(msg,":0203000B0002EE\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(2))
            {
                c2.I3 += val/5;
                break;
            }
            else
            {
failed_q7:      #asm("wdr");
                senderr("#retry_q7\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q7->c2_fail\n");
            ic2=0;
            memset(&c2,0,sizeof(struct DMED301));    //clear param_set
            goto param_set3;
        }

        strcpyf(msg,":020300130002E6\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(2))
            {
                c2.P1 += val/5;
                break;
            }
            else
            {
failed_q8:      #asm("wdr");
                senderr("#retry_q8\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q8->c2_fail\n");
            ic2=0;
            memset(&c2,0,sizeof(struct DMED301));    //clear param_set
            goto param_set3;
        }

        strcpyf(msg,":020300150002E4\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(2))
            {
                c2.P2 += val/5;
                break;
            }
            else
            {
failed_q9:      #asm("wdr");
                senderr("#retry_q9\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q9->c2_fail\n");
            ic2=0;
            memset(&c2,0,sizeof(struct DMED301));    //clear param_set
            goto param_set3;
        }

        strcpyf(msg,":020300170002E2\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(2))
            {
                c2.P3 += val/5;
                break;
            }
            else
            {
failed_q10:     #asm("wdr");
                senderr("#retry_q10\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q10->c2_fail\n");
            ic2=0;
            memset(&c2,0,sizeof(struct DMED301));    //clear param_set
            goto param_set3;
        }

        strcpyf(msg,":020300190002E0\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(2))
            {
                c2.Q1 += val/5;
                break;
            }
            else
            {
failed_q11:     #asm("wdr");
                senderr("#retry_q11\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q11->c2_fail\n");
            ic2=0;
            memset(&c2,0,sizeof(struct DMED301));    //clear param_set
            goto param_set3;
        }

        strcpyf(msg,":0203001B0002DE\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(2))
            {
                c2.Q2 += val/5;
                break;
            }
            else
            {
failed_q12:     #asm("wdr");
                senderr("#retry_q12\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q12->c2_fail\n");
            ic2=0;
            memset(&c2,0,sizeof(struct DMED301));    //clear param_set
            goto param_set3;
        }

        strcpyf(msg,":0203001D0002DC\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(2))
            {
                c2.Q3 += val/5;
                break;
            }
            else
            {
failed_q13:     #asm("wdr");
                senderr("#retry_q13\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q13->c2_fail\n");
            ic2=0;
            memset(&c2,0,sizeof(struct DMED301));    //clear param_set
            goto param_set3;
        }

        strcpyf(msg,":0203001F0002DA\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(2))
            {
                c2.S1 += val/5;
                break;
            }
            else
            {
failed_q14:     #asm("wdr");
                senderr("#retry_q14\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q14->c2_fail\n");
            ic2=0;
            memset(&c2,0,sizeof(struct DMED301));    //clear param_set
            goto param_set3;
        }

        strcpyf(msg,":020300210002D8\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(2))
            {
                c2.S2 += val/5;
                break;
            }
            else
            {
failed_q15:     #asm("wdr");
                senderr("#retry_q15\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q15->c2_fail\n");
            ic2=0;
            memset(&c2,0,sizeof(struct DMED301));    //clear param_set
            goto param_set3;
        }

        strcpyf(msg,":020300230002D6\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(2))
            {
                c2.S3 += val/5;
                break;
            }
            else
            {
failed_q16:     #asm("wdr");
                senderr("#retry_q16\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q16->c2_fail\n");
            ic2=0;
            memset(&c2,0,sizeof(struct DMED301));    //clear param_set
            goto param_set3;
        }



        if(++ic2==5)    // 5 values acquired, insert obtained mean
        {
            sprintf(msg,"CALL insert_em2(%ld,%ld,", c2.I1, c2.I2);
            sendqry();
            #asm("wdr");
            sprintf(msg,"%ld,%ld,%ld,%ld,", c2.I3, c2.P1, c2.P2, c2.P3);
            sendqry();
            #asm("wdr");
            sprintf(msg,"%ld,%ld,%ld,%ld,", c2.Q1, c2.Q2, c2.Q3, c2.S1);
            sendqry();
            #asm("wdr");
            sprintf(msg,"%ld,%ld);\n", c2.S2, c2.S3);
            sendqry();
            #asm("wdr");
            ic2=0;
            memset(&c2,0,sizeof(struct DMED301));    //clear param_set
        }


param_set3:
        strcpyf(msg,":030300070002F1\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(3))
            {
                c3.I1 += val/5;
                break;
            }
            else
            {
failed_q17:     #asm("wdr");
                senderr("#retry_q17\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q17->c3_fail\n");
            ic3=0;
            memset(&c3,0,sizeof(struct DMED301));    //clear param_set
            goto param_set4;
        }

        strcpyf(msg,":030300090002EF\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(3))
            {
                c3.I2 += val/5;
                break;
            }
            else
            {
failed_q18:     #asm("wdr");
                senderr("#retry_q18\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q18->c3_fail\n");
            ic3=0;
            memset(&c3,0,sizeof(struct DMED301));    //clear param_set
            goto param_set4;
        }

        strcpyf(msg,":0303000B0002ED\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(3))
            {
                c3.I3 += val/5;
                break;
            }
            else
            {
failed_q19:     #asm("wdr");
                senderr("#retry_q19\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q19->c3_fail\n");
            ic3=0;
            memset(&c3,0,sizeof(struct DMED301));    //clear param_set
            goto param_set4;
        }

        strcpyf(msg,":030300130002E5\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(3))
            {
                c3.P1 += val/5;
                break;
            }
            else
            {
failed_q20:     #asm("wdr");
                senderr("#retry_q20\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q20->c3_fail\n");
            ic3=0;
            memset(&c3,0,sizeof(struct DMED301));    //clear param_set
            goto param_set4;
        }

        strcpyf(msg,":030300150002E3\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(3))
            {
                c3.P2 += val/5;
                break;
            }
            else
            {
failed_q21:     #asm("wdr");
                senderr("#retry_q21\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q21->c3_fail\n");
            ic3=0;
            memset(&c3,0,sizeof(struct DMED301));    //clear param_set
            goto param_set4;
        }

        strcpyf(msg,":030300170002E1\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(3))
            {
                c3.P3 += val/5;
                break;
            }
            else
            {
failed_q22:     #asm("wdr");
                senderr("#retry_q22\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q22->c3_fail\n");
            ic3=0;
            memset(&c3,0,sizeof(struct DMED301));    //clear param_set
            goto param_set4;
        }

        strcpyf(msg,":030300190002DF\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(3))
            {
                c3.Q1 += val/5;
                break;
            }
            else
            {
failed_q23:     #asm("wdr");
                senderr("#retry_q23\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q23->c3_fail\n");
            ic3=0;
            memset(&c3,0,sizeof(struct DMED301));    //clear param_set
            goto param_set4;
        }

        strcpyf(msg,":0303001B0002DD\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(3))
            {
                c3.Q2 += val/5;
                break;
            }
            else
            {
failed_q24:     #asm("wdr");
                senderr("#retry_q24\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q24->c3_fail\n");
            ic3=0;
            memset(&c3,0,sizeof(struct DMED301));    //clear param_set
            goto param_set4;
        }

        strcpyf(msg,":0303001D0002DB\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(3))
            {
                c3.Q3 += val/5;
                break;
            }
            else
            {
failed_q25:     #asm("wdr");
                senderr("#retry_q25\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q25->c3_fail\n");
            ic3=0;
            memset(&c3,0,sizeof(struct DMED301));    //clear param_set
            goto param_set4;
        }

        strcpyf(msg,":0303001F0002D9\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(3))
            {
                c3.S1 += val/5;
                break;
            }
            else
            {
failed_q26:     #asm("wdr");
                senderr("#retry_q26\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q26->c3_fail\n");
            ic3=0;
            memset(&c3,0,sizeof(struct DMED301));    //clear param_set
            goto param_set4;
        }

        strcpyf(msg,":030300210002D7\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(3))
            {
                c3.S2 += val/5;
                break;
            }
            else
            {
failed_q27:     #asm("wdr");
                senderr("#retry_q27\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q27->c3_fail\n");
            ic3=0;
            memset(&c3,0,sizeof(struct DMED301));    //clear param_set
            goto param_set4;
        }

        strcpyf(msg,":030300230002D5\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(3))
            {
                c3.S3 += val/5;
                break;
            }
            else
            {
failed_q28:     #asm("wdr");
                senderr("#retry_q28\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q28->c3_fail\n");
            ic3=0;
            memset(&c3,0,sizeof(struct DMED301));    //clear param_set
            goto param_set4;
        }



        if(++ic3==5)    // 5 values acquired, insert obtained mean
        {
            sprintf(msg,"CALL insert_em3(%ld,%ld,", c3.I1, c3.I2);
            sendqry();
            #asm("wdr");
            sprintf(msg,"%ld,%ld,%ld,%ld,", c3.I3, c3.P1, c3.P2, c3.P3);
            sendqry();
            #asm("wdr");
            sprintf(msg,"%ld,%ld,%ld,%ld,", c3.Q1, c3.Q2, c3.Q3, c3.S1);
            sendqry();
            #asm("wdr");
            sprintf(msg,"%ld,%ld);\n", c3.S2, c3.S3);
            sendqry();
            #asm("wdr");
            ic3=0;
            memset(&c3,0,sizeof(struct DMED301));    //clear param_set
        }


param_set4:
        strcpyf(msg,":040300070002F0\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(4))
            {
                c4.I1 += val/5;
                break;
            }
            else
            {
failed_q29:     #asm("wdr");
                senderr("#retry_q29\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q29->c4_fail\n");
            ic4=0;
            memset(&c4,0,sizeof(struct DMED301));    //clear param_set
            goto set_relays;
        }

        strcpyf(msg,":040300090002EE\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(4))
            {
                c4.I2 += val/5;
                break;
            }
            else
            {
failed_q30:     #asm("wdr");
                senderr("#retry_q30\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q30->c4_fail\n");
            ic4=0;
            memset(&c4,0,sizeof(struct DMED301));    //clear param_set
            goto set_relays;
        }

        strcpyf(msg,":0403000B0002EC\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(4))
            {
                c4.I3 += val/5;
                break;
            }
            else
            {
failed_q31:     #asm("wdr");
                senderr("#retry_q31\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q31->c4_fail\n");
            ic4=0;
            memset(&c4,0,sizeof(struct DMED301));    //clear param_set
            goto set_relays;
        }

        strcpyf(msg,":040300130002E4\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(4))
            {
                c4.P1 += val/5;
                break;
            }
            else
            {
failed_q32:     #asm("wdr");
                senderr("#retry_q32\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q32->c4_fail\n");
            ic4=0;
            memset(&c4,0,sizeof(struct DMED301));    //clear param_set
            goto set_relays;
        }

        strcpyf(msg,":040300150002E2\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(4))
            {
                c4.P2 += val/5;
                break;
            }
            else
            {
failed_q33:     #asm("wdr");
                senderr("#retry_q33\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q33->c4_fail\n");
            ic4=0;
            memset(&c4,0,sizeof(struct DMED301));    //clear param_set
            goto set_relays;
        }

        strcpyf(msg,":040300170002E0\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(4))
            {
                c4.P3 += val/5;
                break;
            }
            else
            {
failed_q34:     #asm("wdr");
                senderr("#retry_q34\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q34->c4_fail\n");
            ic4=0;
            memset(&c4,0,sizeof(struct DMED301));    //clear param_set
            goto set_relays;
        }

        strcpyf(msg,":040300190002DE\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(4))
            {
                c4.Q1 += val/5;
                break;
            }
            else
            {
failed_q35:     #asm("wdr");
                senderr("#retry_q35\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q35->c4_fail\n");
            ic4=0;
            memset(&c4,0,sizeof(struct DMED301));    //clear param_set
            goto set_relays;
        }

        strcpyf(msg,":0403001B0002DC\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(4))
            {
                c4.Q2 += val/5;
                break;
            }
            else
            {
failed_q36:     #asm("wdr");
                senderr("#retry_q36\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q36->c4_fail\n");
            ic4=0;
            memset(&c4,0,sizeof(struct DMED301));    //clear param_set
            goto set_relays;
        }

        strcpyf(msg,":0403001D0002DA\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(4))
            {
                c4.Q3 += val/5;
                break;
            }
            else
            {
failed_q37:     #asm("wdr");
                senderr("#retry_q37\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q37->c4_fail\n");
            ic4=0;
            memset(&c4,0,sizeof(struct DMED301));    //clear param_set
            goto set_relays;
        }

        strcpyf(msg,":0403001F0002D8\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(4))
            {
                c4.S1 += val/5;
                break;
            }
            else
            {
failed_q38:     #asm("wdr");
                senderr("#retry_q38\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q38->c4_fail\n");
            ic4=0;
            memset(&c4,0,sizeof(struct DMED301));    //clear param_set
            goto set_relays;
        }

        strcpyf(msg,":040300210002D6\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(4))
            {
                c4.S2 += val/5;
                break;
            }
            else
            {
failed_q39:     #asm("wdr");
                senderr("#retry_q39\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q39->c4_fail\n");
            ic4=0;
            memset(&c4,0,sizeof(struct DMED301));    //clear param_set
            goto set_relays;
        }

        strcpyf(msg,":040300230002D4\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate03(4))
            {
                c4.S3 += val/5;
                break;
            }
            else
            {
failed_q40:     #asm("wdr");
                senderr("#retry_q40\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q40->c4_fail\n");
            ic4=0;
            memset(&c4,0,sizeof(struct DMED301));    //clear param_set
            goto set_relays;
        }


        if(++ic4==5)    // 5 values acquired, insert obtained mean
        {
            sprintf(msg,"CALL insert_em4(%ld,%ld,", c4.I1, c4.I2);
            sendqry();
            #asm("wdr");
            sprintf(msg,"%ld,%ld,%ld,%ld,", c4.I3, c4.P1, c4.P2, c4.P3);
            sendqry();
            #asm("wdr");
            sprintf(msg,"%ld,%ld,%ld,%ld,", c4.Q1, c4.Q2, c4.Q3, c4.S1);
            sendqry();
            #asm("wdr");
            sprintf(msg,"%ld,%ld);\n", c4.S2, c4.S3);
            sendqry();
            #asm("wdr");
            ic4=0;
            memset(&c4,0,sizeof(struct DMED301));    //clear param_set
        }

set_relays:
        if(pinA!=pinAbak)
        {
            pinAreq = pinA;
            LRC_TX= -0x05 -0x06 -pinAreq;
            sprintf(msg, ":0506000000%02X%02X\r\n", pinAreq,LRC_TX);

            for(iretry=0; iretry<3; iretry++)
            {
                if(!ask_listen_validate06())
                    break;
                else
                {
failed_q41:         #asm("wdr");
                    senderr("#retry_q41\n");
                }
            }
            if(iretry==3)
                senderr("#failed_q41\n");
            else
                pinAbak=pinAreq;
        }

slave05_params:
        strcpyf(msg,":050400010001F5\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate04(&s5.powcon))
                break;
            else
            {
failed_q42:     #asm("wdr");
                senderr("#retry_q42\n");
            }
        }
        if(iretry==3)
            senderr("#failed_q42\n");
        else
            PORTC=s5.powcon;

        strcpyf(msg,":050400040001F2\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate04(&retval))
            {
                s5.ain4 += retval/5;
                break;
            }
            else
            {
failed_q43:     #asm("wdr");
                senderr("#retry_q43\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q43->s5_fail\n");
            is5=0;
            memset(&s5,0,sizeof(struct Slave05));    //clear param_set
            goto end_acquisition_cycle;
        }

        strcpyf(msg,":050400050001F1\r\n");
        for(iretry=0; iretry<3; iretry++)
        {
            if(!ask_listen_validate04(&retval))
            {
                s5.ain5 += retval/5;
                break;
            }
            else
            {
failed_q44:     #asm("wdr");
                senderr("#retry_q44\n");
            }
        }
        if(iretry==3)
        {
            senderr("#failed_q44->s5_fail\n");
            is5=0;
            memset(&s5,0,sizeof(struct Slave05));    //clear param_set
            goto end_acquisition_cycle;
        }

        if(++is5==5)    // 5 values acquired, insert obtained mean
        {
            sprintf(msg,"CALL insert_slave5(%d,", s5.ain4);
            sendqry();
            #asm("wdr");
            sprintf(msg,"%d);\n", s5.ain5);
            sendqry();
            #asm("wdr");
            is5=0;
            memset(&s5,0,sizeof(struct Slave05));    //clear param_set
        }

end_acquisition_cycle:
        /*do
        {
            time1 = TCNT1L | (TCNT1H<<8);
            #asm("wdr");
        }
        while (time1 != 0xB71A);*/
        while(time1= TCNT1L|(TCNT1H<<8),  time1 != 0xB71A)    #asm("wdr");    //param_set1...4+q41...q44 acquisition should take no less than 12s
        //while(TCNT1L != OCR1AL  ||  TCNT1H != OCR1AH)    #asm("wdr");    //param_set1...4+q41...q44 acquisition should take no less than 12s

        if(rx_buffer_overflow1)
        {
            senderr("#RX1_buffer_overflow");
            rx_buffer_overflow1 = 0;
        }
    }
}
