/*******************************************************
This program was created by the CodeWizardAVR V3.37 
Automatic Program Generator
© Copyright 1998-2019 Pavel Haiduc, HP InfoTech s.r.l.
http://www.hpinfotech.com

Project : Transceiver interface
Version : 0.958
Date    : 5.01.2023
Author  : popag93
Company : 
Comments: sends UART1 messages to energy meter through transceiver to poll voltage,
          forwards USART1 to USART0 and takes care of transceiver data direction bit


Chip type               : ATmega164A
Program type            : Application
AVR Core Clock frequency: 20.000000 MHz
Memory model            : Small
External RAM size       : 0
Data Stack size         : 256
*******************************************************/

#include <mega164a.h>

#include <stdio.h>
#include <stdlib.h>
#include <delay.h>
#include "defs.h"
void initController();

bit key;    //stable registered value for PIND.5


//*************************************************************************************************
//*********** BEGIN SERIAL STUFF (interrupt-driven, generated by Code Wizard) *********************
//*************************************************************************************************

#ifndef RXB8
#define RXB8 1
#endif

#ifndef TXB8
#define TXB8 0
#endif

#ifndef UPE
#define UPE 2
#endif

#ifndef DOR
#define DOR 3
#endif

#ifndef FE
#define FE 4
#endif

#ifndef UDRE
#define UDRE 5
#endif

#ifndef RXC
#define RXC 7
#endif

#define FRAMING_ERROR (1<<FE)
#define PARITY_ERROR (1<<UPE)
#define DATA_OVERRUN (1<<DOR)
#define DATA_REGISTER_EMPTY (1<<UDRE)
#define RX_COMPLETE (1<<RXC)

// USART0 Receiver buffer
#define RX_BUFFER_SIZE0 256
char rx_buffer0[RX_BUFFER_SIZE0];        //este un FIFO circular, wr_index pt intrari, rd_index pt iesiri

#if RX_BUFFER_SIZE0 <= 256
unsigned char rx_wr_index0,rx_rd_index0,rx_counter0;    //rx_counter0 counts unread data in the buffer
#else
unsigned int rx_wr_index0,rx_rd_index0,rx_counter0;
#endif

// This flag is set on USART0 Receiver buffer overflow
bit rx_buffer_overflow0;

// USART0 Receiver interrupt service routine
interrupt [USART0_RXC] void usart0_rx_isr(void)        //keyword "interrupt[<IV_index>]" ...<functie>
{
    char status,data;
    status=UCSR0A;
    data=UDR0;    //dupa se va sterge RXCF de hard
    if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)  //if(!(status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN)))
       {
       rx_buffer0[rx_wr_index0++]=data;
    #if RX_BUFFER_SIZE0 == 256
       // special case for receiver buffer size=256
       if (++rx_counter0 == 0) rx_buffer_overflow0=1;
    #else
       if (rx_wr_index0 == RX_BUFFER_SIZE0) rx_wr_index0=0;
       if (++rx_counter0 == RX_BUFFER_SIZE0)
          {
          rx_counter0=0;
          rx_buffer_overflow0=1;
          }
    #endif
       }
}

#ifndef _DEBUG_TERMINAL_IO_
// Get a character from the USART0 Receiver buffer
#define _ALTERNATE_GETCHAR_
#pragma used+
char getchar0(void)
{
    char data;
    while (rx_counter0==0);        //while no new data is present, wait
    data=rx_buffer0[rx_rd_index0++];
    #if RX_BUFFER_SIZE0 != 256
    if (rx_rd_index0 == RX_BUFFER_SIZE0) rx_rd_index0=0;
    #endif
    #asm("cli")
    --rx_counter0;    //oprit intreruperi deoarece operatie atomica ???
    #asm("sei")
    return data;
}
#pragma used-
#endif

// USART0 Transmitter buffer
#define TX_BUFFER_SIZE0 8
char tx_buffer0[TX_BUFFER_SIZE0];    //este un FIFO circular, wr_index pt intrari, rd pt iesiri catre TransmitBuffer

#if TX_BUFFER_SIZE0 <= 256
unsigned char tx_wr_index0,tx_rd_index0,tx_counter0;
#else
unsigned int tx_wr_index0,tx_rd_index0,tx_counter0;
#endif

// USART0 Transmitter interrupt service routine
interrupt [USART0_TXC] void usart0_tx_isr(void)
{
    if (tx_counter0)        //else, the buffer is empty, do nothing, starting the ISR clears TXCF
       {
       --tx_counter0;
       UDR0=tx_buffer0[tx_rd_index0++];
    #if TX_BUFFER_SIZE0 != 256
       if (tx_rd_index0 == TX_BUFFER_SIZE0) tx_rd_index0=0;
    #endif
       }
}

#ifndef _DEBUG_TERMINAL_IO_
// Write a character to the USART0 Transmitter buffer
#define _ALTERNATE_PUTCHAR_
#pragma used+
void putchar0(char c)
{
    while (tx_counter0 == TX_BUFFER_SIZE0);        //? si daca BUFFER_SIZE0==256 ??
    #asm("cli")
    if (tx_counter0 || ((UCSR0A & DATA_REGISTER_EMPTY)==0))      //a doua conditie este pt a nu fi in cazul in care doar ce am golit buffer-ul, insa nu s-a golit UDR0
       {
       tx_buffer0[tx_wr_index0++]=c;
    #if TX_BUFFER_SIZE0 != 256
       if (tx_wr_index0 == TX_BUFFER_SIZE0) tx_wr_index0=0;
    #endif
       ++tx_counter0;
       }
    else        //inseamna ca TXC=0 (sters de ISR) si UDRE=1
       UDR0=c;
    #asm("sei")
}
#pragma used-
#endif
//*************************************************************************************************
//******************** END SERIAL STUFF (USART0), BEGIN USART1  ***********************************
//*************************************************************************************************

// USART1 Receiver buffer
#define RX_BUFFER_SIZE1 256
char rx_buffer1[RX_BUFFER_SIZE1];        //wr_index pt intrari, rd_index pt iesiri

#if RX_BUFFER_SIZE1 <= 256
unsigned char rx_wr_index1,rx_rd_index1,rx_counter1;    //rx_counter counts unread data in the buffer
#else
unsigned int rx_wr_index1,rx_rd_index1,rx_counter1;
#endif

// This flag is set on USART1 Receiver buffer overflow
bit rx_buffer_overflow1;

// USART1 Receiver interrupt service routine
interrupt [USART1_RXC] void usart1_rx_isr(void)        //keyword "interrupt[<IV_index>]" ...<functie>
{
    char status,data;
    status=UCSR1A;
    data=UDR1;    //dupa se va sterge RXCF de hard
    if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)  //if(!(status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN)))
       {
       rx_buffer1[rx_wr_index1++]=data;
    #if RX_BUFFER_SIZE1 == 256
       // special case for receiver buffer size=256
       if (++rx_counter1 == 0) rx_buffer_overflow1=1;
    #else
       if (rx_wr_index1 == RX_BUFFER_SIZE1) rx_wr_index1=0;
       if (++rx_counter1 == RX_BUFFER_SIZE1)
          {
          rx_counter1=0;
          rx_buffer_overflow1=1;
          }
    #endif
       }
}

#pragma used+
char getchar1(void)
{
    char data;
    while (rx_counter1==0);        //while no new data is present, wait
    data=rx_buffer1[rx_rd_index1++];
    #if RX_BUFFER_SIZE1 != 256
    if (rx_rd_index1 == RX_BUFFER_SIZE1) rx_rd_index1=0;
    #endif
    #asm("cli")
    --rx_counter1;    //oprit intreruperi deoarece operatie atomica ???
    #asm("sei")
    return data;
}
#pragma used-

// USART1 Transmitter buffer
#define TX_BUFFER_SIZE1 8
char tx_buffer1[TX_BUFFER_SIZE1];    //wr_index pt intrari, rd pt iesiri catre TransmitBuffer

#if TX_BUFFER_SIZE1 <= 256
unsigned char tx_wr_index1,tx_rd_index1,tx_counter1;
#else
unsigned int tx_wr_index1,tx_rd_index1,tx_counter1;
#endif

// USART1 Transmitter interrupt service routine
interrupt [USART1_TXC] void usart1_tx_isr(void)
{
    if (tx_counter1)        //else, the buffer is empty, do nothing, starting the ISR clears TXCF
       {
       --tx_counter1;
       UDR1=tx_buffer1[tx_rd_index1++];
    #if TX_BUFFER_SIZE1 != 256
       if (tx_rd_index1 == TX_BUFFER_SIZE1) tx_rd_index1=0;
    #endif
       }
    else
        transceiver_datadir=0;
}

#pragma used+
void putchar1(char c)
{
    while (tx_counter1 == TX_BUFFER_SIZE1);        //? si daca BUFFER_SIZE1==256 ??
    #asm("cli")
    if (tx_counter1 || ((UCSR1A & DATA_REGISTER_EMPTY)==0))      //a doua conditie este pt a nu fi in cazul in care doar ce am golit buffer-ul, insa nu s-a golit UDR0
       {
       tx_buffer1[tx_wr_index1++]=c;
    #if TX_BUFFER_SIZE1 != 256
       if (tx_wr_index1 == TX_BUFFER_SIZE1) tx_wr_index1=0;
    #endif
       ++tx_counter1;
       }
    else        //inseamna ca TXC=0 (sters de ISR) si UDRE=1
       UDR1=c;
    #asm("sei")
}
#pragma used-
//*************************************************************************************************
//************************* END SERIAL STUFF (USART1) *********************************************
//*************************************************************************************************


void start_timer2()
{
    TCCR2B=0b0111;
}

void stop_timer2()
{
    TCCR2B=0;
}

// Pin change 24-31 interrupt service routine
interrupt [PC_INT3] void pin_change_isr3(void)
{
    // Place your code here
    TCCR2B=0b0111;
    TCNT2=0x00;    //start timer from 0
}



// Timer2 output compare interrupt service routine
interrupt [TIM2_COMPA] void timer2_compa_isr(void)
{
    // Place your code here
    TCCR2B=0x00;    //stop timer
    key=KEY;
}


void main(void)
{
    char *ct, cr;
    char *predef_msg1=":010300010002F9\r\n";
    unsigned char i=0;
    
    initController();
    key=KEY;
    // Globally enable interrupts
    #asm("sei")
    while (1)
    {
        // Place your code here
        delay_ms(2000);
        #asm("wdr");
        transceiver_datadir=1;
        for(ct=predef_msg1; *ct; ct++)
        {
            putchar0(*ct);
            putchar1(*ct);
        }
        #asm("wdr");
        while(!rx_counter1);    //wait for response
        #asm("wdr");
        while(rx_counter1 || cr!='\n')
        {
            cr=getchar1();
            putchar0(cr);
        }
    }
}