/*******************************************************
This program was created by the CodeWizardAVR V3.37 
Automatic Program Generator
© Copyright 1998-2019 Pavel Haiduc, HP InfoTech s.r.l.
http://www.hpinfotech.com

Project : Transceiver interface
Version : 0.8
Date    : 11.01.2023
Author  : popag93
Company : 
Comments: queries the meter, computes mean on 5s from 5 values
          and sends MySQL queries on USART0 to insert metrics

Chip type               : ATmega164A
Program type            : Application
AVR Core Clock frequency: 20.000000 MHz
Memory model            : Small
External RAM size       : 0
Data Stack size         : 256
*******************************************************/

#include <mega164a.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <delay.h>
#include "defs.h"
void initController();

//static const char hextable[] = {[0...255]=-1, ['0']=0,1,2,3,4,5,6,7,8,9, ['A']=10,11,12,13,14,15, ['a']=10,11,12,13,14,15};
//normally I would use flash storage
flash const char hextable[] = {
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1, 0,1,2,3,4,5,6,7,8,9,-1,-1,-1,-1,-1,-1,-1,10,11,12,13,14,15,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
    -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
};
void sscanf_2hhx(char *s, char *d)    //call this instead of sscanf(s, "%2hhx", d), which is not implemented
{
    *d=0;
    if(hextable[s[0]]!=-1)
        *d = hextable[s[0]]<<4;
    else
        return;
    if(hextable[s[1]]!=-1)
        *d += hextable[s[1]];
    
    return;
}

//*************************************************************************************************
//*********** BEGIN SERIAL STUFF (interrupt-driven, generated by Code Wizard) *********************
//*************************************************************************************************
#define getchar0 getchar
#define putchar0 putchar

#ifndef RXB8
#define RXB8 1
#endif

#ifndef TXB8
#define TXB8 0
#endif

#ifndef UPE
#define UPE 2
#endif

#ifndef DOR
#define DOR 3
#endif

#ifndef FE
#define FE 4
#endif

#ifndef UDRE
#define UDRE 5
#endif

#ifndef RXC
#define RXC 7
#endif

#define FRAMING_ERROR (1<<FE)
#define PARITY_ERROR (1<<UPE)
#define DATA_OVERRUN (1<<DOR)
#define DATA_REGISTER_EMPTY (1<<UDRE)
#define RX_COMPLETE (1<<RXC)

// USART0 Receiver buffer
#define RX_BUFFER_SIZE0 8
char rx_buffer0[RX_BUFFER_SIZE0];        //este un FIFO circular, wr_index pt intrari, rd_index pt iesiri

#if RX_BUFFER_SIZE0 <= 256
unsigned char rx_wr_index0,rx_rd_index0,rx_counter0;    //rx_counter0 counts unread data in the buffer
#else
unsigned int rx_wr_index0,rx_rd_index0,rx_counter0;
#endif

// This flag is set on USART0 Receiver buffer overflow
bit rx_buffer_overflow0;

// USART0 Receiver interrupt service routine
interrupt [USART0_RXC] void usart0_rx_isr(void)        //keyword "interrupt[<IV_index>]" ...<functie>
{
    char status,data;
    status=UCSR0A;
    data=UDR0;    //dupa se va sterge RXCF de hard
    if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)  //if(!(status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN)))
       {
       rx_buffer0[rx_wr_index0++]=data;
    #if RX_BUFFER_SIZE0 == 256
       // special case for receiver buffer size=256
       if (++rx_counter0 == 0) rx_buffer_overflow0=1;
    #else
       if (rx_wr_index0 == RX_BUFFER_SIZE0) rx_wr_index0=0;
       if (++rx_counter0 == RX_BUFFER_SIZE0)
          {
          rx_counter0=0;
          rx_buffer_overflow0=1;
          }
    #endif
       }
}

#ifndef _DEBUG_TERMINAL_IO_
// Get a character from the USART0 Receiver buffer
#define _ALTERNATE_GETCHAR_
#pragma used+
char getchar0(void)
{
    char data;
    while (rx_counter0==0);        //while no new data is present, wait
    data=rx_buffer0[rx_rd_index0++];
    #if RX_BUFFER_SIZE0 != 256
    if (rx_rd_index0 == RX_BUFFER_SIZE0) rx_rd_index0=0;
    #endif
    #asm("cli")
    --rx_counter0;    //oprit intreruperi deoarece operatie atomica ???
    #asm("sei")
    return data;
}
#pragma used-
#endif

// USART0 Transmitter buffer
#define TX_BUFFER_SIZE0 24
char tx_buffer0[TX_BUFFER_SIZE0];    //este un FIFO circular, wr_index pt intrari, rd pt iesiri catre TransmitBuffer

#if TX_BUFFER_SIZE0 <= 256
unsigned char tx_wr_index0,tx_rd_index0,tx_counter0;
#else
unsigned int tx_wr_index0,tx_rd_index0,tx_counter0;
#endif

// USART0 Transmitter interrupt service routine
interrupt [USART0_TXC] void usart0_tx_isr(void)
{
    if (tx_counter0)        //else, the buffer is empty, do nothing, starting the ISR clears TXCF
    {
       --tx_counter0;
       UDR0=tx_buffer0[tx_rd_index0++];
    #if TX_BUFFER_SIZE0 != 256
       if (tx_rd_index0 == TX_BUFFER_SIZE0) tx_rd_index0=0;
    #endif
    }
}

#ifndef _DEBUG_TERMINAL_IO_
// Write a character to the USART0 Transmitter buffer
#define _ALTERNATE_PUTCHAR_
#pragma used+
void putchar0(char c)
{
    while (tx_counter0 == TX_BUFFER_SIZE0);        //? si daca BUFFER_SIZE0==256 ??
    #asm("cli")
    if (tx_counter0 || ((UCSR0A & DATA_REGISTER_EMPTY)==0))      //a doua conditie este pt a nu fi in cazul in care doar ce am golit buffer-ul, insa nu s-a golit UDR0
       {
       tx_buffer0[tx_wr_index0++]=c;
    #if TX_BUFFER_SIZE0 != 256
       if (tx_wr_index0 == TX_BUFFER_SIZE0) tx_wr_index0=0;
    #endif
       ++tx_counter0;
       }
    else        //inseamna ca TXC=0 (sters de ISR) si UDRE=1
       UDR0=c;
    #asm("sei")
}
#pragma used-
#endif
//*************************************************************************************************
//******************** END SERIAL STUFF (USART0), BEGIN USART1  ***********************************
//*************************************************************************************************

// USART1 Receiver buffer
#define RX_BUFFER_SIZE1 32
char rx_buffer1[RX_BUFFER_SIZE1];        //wr_index pt intrari, rd_index pt iesiri

#if RX_BUFFER_SIZE1 <= 256
unsigned char rx_wr_index1,rx_rd_index1,rx_counter1;    //rx_counter counts unread data in the buffer
#else
unsigned int rx_wr_index1,rx_rd_index1,rx_counter1;
#endif

// This flag is set on USART1 Receiver buffer overflow
bit rx_buffer_overflow1;

// USART1 Receiver interrupt service routine
interrupt [USART1_RXC] void usart1_rx_isr(void)        //keyword "interrupt[<IV_index>]" ...<functie>
{
    char status,data;
    status=UCSR1A;
    data=UDR1;    //dupa se va sterge RXCF de hard
    if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)  //if(!(status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN)))
    {
        rx_buffer1[rx_wr_index1++]=data;
    #if RX_BUFFER_SIZE1 == 256
        // special case for receiver buffer size=256
        if (++rx_counter1 == 0) rx_buffer_overflow1=1;
    #else
        if (rx_wr_index1 == RX_BUFFER_SIZE1) rx_wr_index1=0;
        if (++rx_counter1 == RX_BUFFER_SIZE1)
        {
            rx_counter1=0;
            rx_buffer_overflow1=1;
        }
    #endif
    }
}

#pragma used+
char getchar1(void)
{
    char data;
    while (rx_counter1==0);        //while no new data is present, wait
    data=rx_buffer1[rx_rd_index1++];
    #if RX_BUFFER_SIZE1 != 256
    if (rx_rd_index1 == RX_BUFFER_SIZE1) rx_rd_index1=0;
    #endif
    #asm("cli")
    --rx_counter1;    //oprit intreruperi deoarece operatie atomica ???
    #asm("sei")
    return data;
}
#pragma used-

// USART1 Transmitter buffer
#define TX_BUFFER_SIZE1 24
char tx_buffer1[TX_BUFFER_SIZE1];    //wr_index pt intrari, rd pt iesiri catre TransmitBuffer

#if TX_BUFFER_SIZE1 <= 256
unsigned char tx_wr_index1,tx_rd_index1,tx_counter1;
#else
unsigned int tx_wr_index1,tx_rd_index1,tx_counter1;
#endif

// USART1 Transmitter interrupt service routine
interrupt [USART1_TXC] void usart1_tx_isr(void)
{
    if (tx_counter1)        //else, the buffer is empty, do nothing, starting the ISR clears TXCF
    {
       --tx_counter1;
       UDR1=tx_buffer1[tx_rd_index1++];
    #if TX_BUFFER_SIZE1 != 256
       if (tx_rd_index1 == TX_BUFFER_SIZE1) tx_rd_index1=0;
    #endif
    }
    else
    {
        transceiver_datadir=0;
        LED1=0;
    }
}

#pragma used+
void putchar1(char c)
{
    while (tx_counter1 == TX_BUFFER_SIZE1);        //? si daca BUFFER_SIZE1==256 ??
    #asm("cli")
    if (tx_counter1 || ((UCSR1A & DATA_REGISTER_EMPTY)==0))      //a doua conditie este pt a nu fi in cazul in care doar ce am golit buffer-ul, insa nu s-a golit UDR0
    {
       tx_buffer1[tx_wr_index1++]=c;
    #if TX_BUFFER_SIZE1 != 256
       if (tx_wr_index1 == TX_BUFFER_SIZE1) tx_wr_index1=0;
    #endif
       ++tx_counter1;
    }
    else        //inseamna ca TXC=0 (sters de ISR) si UDRE=1
       UDR1=c;
    #asm("sei")
}
#pragma used-
//*************************************************************************************************
//************************* END SERIAL STUFF (USART1) *********************************************
//*************************************************************************************************

struct DMED121{
    // long int in CVAVR C Compiler is int32_t, int is int16_t
    unsigned long int I;    //current
    unsigned long int P;    //active power
    unsigned long int Q;    //reactive power
    unsigned long int S;    //apparent power
};

char time0;    //time0 sw timer - 125 steps; hw timer 125 steps, 64 prescaler -> 64/20000*125*125=50ms
inline void start_timer0()
{
    time0=0;
    TCNT0=0;
    TCCR0B=0b0011;
}
inline void stop_timer0()
{
    TCCR0B=0;
}
// Timer 0 output compare A interrupt service routine
interrupt [TIM0_COMPA] void timer0_compa_isr(void)
{
    if(time0<125)
        time0++;
    else
        TCCR0B=0;
}

inline void start_timer1()
{
    TCNT1H=0;
    TCNT1L=0;
    TCCR1B=0b1101;
}
inline void stop_timer1()
{
    TCCR1B=0;
}
// Timer1 output compare A interrupt service routine
interrupt [TIM1_COMPA] void timer1_compa_isr(void)
{
    TCCR1B=0x00;    //stop timer
}



char cr=0, *ct;
char msg[40], errmsg[24];
void senderr(flash const char *error)
{
    strcpyf(errmsg,error);
    LED1=1;
    for(ct=errmsg; *ct; ct++)
        putchar0(*ct);
    return;
}
void sendmsg()
{
    transceiver_datadir=1;
    LED1=1;
    for(ct=msg; *ct; ct++)
        putchar1(*ct);
    return;
}
void sendqry()
{
    for(ct=msg; *ct; ct++)
        putchar0(*ct);
    return;
}


void main(void)
{
    char rsp[64], Nrsp;    //Nrsp - rsp[] after last element index (==length)
    char LRC;
    unsigned char i=0, iretry, ic1=0, ic2=0, ic3=0, ic4=0;
    struct DMED121 c1;                //measurement set for energymeter 1
    unsigned int time1;
    unsigned long int val;
    
    initController();
    memset(&c1, 0, sizeof(struct DMED121));
    //memset(c2, 0,...
    // Globally enable interrupts
    #asm("sei")
    senderr("#reset\r\n");
    while (1)
    {
    
param_set1:
        start_timer1();
        #asm("wdr");        
        strcpyf(msg, ":010300010002F9\r\n");    //:010300070002F3\r\n
        for(iretry=0; iretry<3; iretry++)
        {
            sendmsg();
            
            start_timer0();
            
            while(!rx_counter1)    //wait first char, timeout time0
                if(time0 == 125)
                {
                    senderr("fail1\r\n");
                    goto failed_q1;
                }
            cr=getchar1();
            *rsp=cr;
            Nrsp=1;
            while(cr!='\n')        //like Linux canonical serial com + timeout
            {
                if(time0 == 125)
                {
                    senderr("fail2\r\n");
                    goto failed_q1;
                }
                if(rx_counter1)
                {
                    cr=getchar1();
                    rsp[Nrsp++]=cr;
                }
            }
            rsp[Nrsp++]='\0';
            
            stop_timer0();
            #asm("wdr");
            
            
            for(i=0;  Nrsp-i>20 && rsp[i]!=':';  i++);    //ignore leading noise
            if(Nrsp-i != 20)                              //without leading noise, 20B response expected (including '\0', begins with ':'
            {
                senderr("fail3\r\n");
                goto failed_q1;
            }
            
            if(strncmpf(rsp, ":01", 3))
                continue;
            LRC = -1;
            
            if(strncmpf(rsp+3, "0304", 4))
                goto failed_q1;
            LRC -= 7;
            
            sscanf(rsp+7,"%8lx",&val);
            LRC -= (val>>24) + (val>>16) + (val>>8) + val;
            
            sscanf_2hhx(rsp+15, &cr);
            if(LRC != cr)
            {
                senderr("#LRCfail");
                goto failed_q1;
            }
            c1.I += val/5;
            break;    //'\r' before last char test ignored 
            
failed_q1:  #asm("wdr");
            senderr("#retry_q1");
        }
        if(iretry==3)
        {
            senderr("#failed_q1->c1_fail");
            ic1=0;
            memset(&c1,0,sizeof(struct DMED121));    //clear param_set
            goto param_set2;
        }
        /*
        strcpyf(msg,"");
        for(iretry=0; iretry<4; iretry++)
        {
            ;
        }
        
        strcpyf(msg,"");
        for(iretry=0; iretry<4; iretry++)
        {
            ;
        }
        
        strcpyf(msg,"");
        for(iretry=0; iretry<4; iretry++)
        {
            ;
        }
        */
        if(++ic1==5)    // 5 values acquired, insert obtained mean
        {
            strcpyf(msg,"CALL insert_em1(");
            sendqry();
            sprintf(msg,"%ld,%ld,%ld,%ld);", c1.I, c1.P, c1.Q, c1.S);
            sendqry();
            ic1=0;
            memset(&c1,0,sizeof(struct DMED121));    //clear param_set
        }
        
        
        
param_set2:
        ;        

param_set3:
        ;

param_set4:
        ;
        
        /*do
        {
            time1 = TCNT1L | (TCNT1H<<8);
            #asm("wdr");
        }
        while (time1 != 0xB71A);*/
        while(time1= TCNT1L|(TCNT1H<<8),  time1 != 0xB71A)    #asm("wdr");    //param_setx acquisition should take no less than 12s
        //while(TCNT1L != OCR1AL  ||  TCNT1H != OCR1AH)    #asm("wdr");    //param_setx acquisition should take no less than 12s
        
        if(rx_buffer_overflow1)
        {
            senderr("RX1_buffer_overflow");
            rx_buffer_overflow1 = 0;
        }
    }
}